# 垃圾收集算法

## 1.标记清除算法
首先标记出需要清除的对象，在标记完成后统一回收掉被清除的部分。这是最基础的一种算法，后续所有收集算法均是基于这种思路，并对其缺点进行改进而得到，它的缺点主要有2个：
(1).效率问题，标记和清除的速度都很慢
(2).空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致将来在程序运行中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

## 2.复制收集算法

将内存划分为两块，当一块实用完了。就将这一块上存活的对象复制到另一块上，再把已使用过的内存空间一次清理掉。代价是内存空间使用只有原来的一半。

现代商业虚拟机均是采用这种算法来回收！！！新生代！！！。IBM研究表明，新生代中90%的对象都是朝生夕死的。所以并不需要1:1来切分空间。而是将内存分为一块较大的Eden空间和两块较小的Survivor。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性拷贝到另外一块Survivor上。最后清理掉刚才使用的Survivor和Eden。如果Survivor的内存不足，这些对象将直接通过分配担保机制进入老年代(这部分在后续章节)

## 3.标记整理算法

为了避免对象全部存活的情况，在老生代不能直接选用复制收集算法。与标记清除算法类似。但是后续步骤不是对对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

## 4.分代收集算法

根据对象的活动周期，将内存分为几块。一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最合适的收集算法。在新生代中，每次垃圾回收都有大量对象死去，所以选用复制算法，只需复制少量对象即可完成收集。而老年代中，因为对象存活率高，所以采用标记清除或者标记整理法来进行回收。

