##简述
Java虚拟机在执行Java程序的时候会将其所管理的内存划分为若干个不同的区域，每个区域的用途。创建销毁的时间各不相同。有的区域随着虚拟机进程启动而存在，而有些则是依赖用户线程的启动/结束而建立/销毁。

## 1.1程序计数器
程序计数器是一块小的内存空间，可以看作是当前线程所执行字节码的指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选去下一条需要执行的字节码命令。分支，循环，跳转，异常，线程恢复等功能，均需依赖这个计数器来完成。

由于Java虚拟机是通过切换线程轮流分配处理器执行时间，因此为了线程切换后能恢复正确执行的位置。每条线程都有一个独立的计数器，各个线程互不影响，我们称之为"线程私有"内存。

如果线程执行的是一个Java方法，那么这个计数器记录的是正在执行的虚拟机字节码的指令地址；如果是Native方法，则这个计数器为空。

此外，这是唯一一个虚拟机规范中没有规定OOM的区域。

## 1.2Java虚拟机栈

和计数器一样，也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法被执行的内存模型：每个方法被执行的时候都会创建一个栈帧(Stack Frame)，用于存放局部变量表，操作栈，动态链接，方法出入口等信息。每一个方法被调用执行完成的过程。

局部变量表存放了基本类型，对象引用，和returnAddress类型(指向了一条字节码指令的地址)。局部变量表所需的内存空间在编译时完成分配。当进入一个方法时，这个方法在帧中所需的局部变量空间是完全确定的，方法运行期间不会改变局部变量的大小。(存疑)

在Java虚拟机规范中，对此空间规定了两种异常情况：如果线程请求的栈深度大于了虚拟机规定的深度stack overflow，如果虚拟机栈动态扩展无法申请到足够内存的时候outofmemory

## 1.3本地方法栈

与Java虚拟机栈类似，Java虚拟机栈为虚拟机执行的Java方法服务。本地方法栈为虚拟机所使用的native方法进行服务

## 1.4Java堆

Java堆是Java虚拟机管理内存中最大的一块，在虚拟机创建的时候创建。此区域的唯一目的就是存放对象实例。几乎所有对象实例都是在这里分配内存。Java堆是垃圾收集器的主要管理区域。因此很多时候被称为GC堆。由于现在收集器都是采用分代手机算法。Java堆还可以细分为新生代，老年代。或者再细一点:Eden空间,From Survivor空间,To Survivor空间。Java堆可以处于物理上不连续的空间中。只要逻辑上为连续的即可。如果在堆中没有内存完成实例分配，且无法扩展的时候，会抛出OOM。

## 1.5方法区

方法区和堆一样，各个线程的内存共享区域。用于存储已被虚拟机加载的类的信息常量，静态变量，即时编译器编译后的代码数据。


## 1.6常量池

常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息就是常量池。用于存放编译期产生的各种字面变量和引用，这部分内容当类被加载后存放在常量池中。运行期间也可以将变量放入常量池中。

For Example:

```java
String s0 = "DingoWong";
        String s1 = new String("DingoWong");
        String s2 = new String("DingoWong");
        System.out.println(s1 == s2);
        s1 = s1.intern();//查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；
        s2 = s1.intern();
        System.out.println(s1 == s2);
        System.out.println(s0 == s2);
```

## 1.7直接内存

并不是虚拟机	运行时数据的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分被频繁使用，也可能导致oom(这一块以后再细看，)

